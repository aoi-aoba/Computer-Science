# C02-03(1) CPU(1) : 레지스터와 인터럽트

## #. 안내
> Computer Science(컴퓨터 과학) 관련 공부 후 직접 정리하는 정리본입니다.   
책을 기반으로 하고 있으나, 위키백과나 StackOverFlow 등의 사이트에서 추가로 더 알아보고 적는 내용들이 많이 있습니다.

---

## A. 레지스터
레지스터(Register)는 CPU 안의 작은 **임시 저장장치**&ZeroWidthSpace;이다. 다양한 종류의 레지스터가 각기 다른 이름과 역할을 가지는데 프로그램을 이루는 데이터와 명령어가 실행 전후로 레지스터에 저장되기 때문에 값만 잘 관찰해도 낮은 수준의 프로그램이 어떻게 작동하는지 알 수 있다. WinDBg(Windows)/gdb(Linux, MacOS) 등의 디버깅 도구로 관찰이 가능하다.

레지스터의 세세한 종류와 이름은 조금씩 다르지만 대부분의 CPU가 공통적으로 포함하는 주요 레지스터들의 이름과 역할을 살펴보자.
<br>

### 1. 프로그램 카운터(PC, Program Counter)
- 메모리에서 다음으로 읽어 들일 **명령어의 주소를 저장**
- **명령어 포인터**&ZeroWidthSpace;(IP, Instuction Pointer)라고도 부름
- 일반적으로는 1씩 증가하여 저장된 프로그램을 **순차적으로** 실행할 수 있게 함
- 필요에 따라 조건문/리턴문 등에서 **카운터 값을 임의로 변경** 하기도 함
<br>

### 2. 명령어 레지스터(IR, Instruction Register)
- 메모리에서 방금 읽어들인 **해석해야 하는 명령어** 저장
- CPU 내의 **제어장치**&ZeroWidthSpace;는 명령어 레지스터 속 명령어를 해석함
- 제어장치가 이를 받아들여 **ALU(산술논리연산장치)**&ZeroWidthSpace;로 하여금 연산하게 시키거나 다른 부품으로 제어 신호를 보내 부품을 작동
<br>

### 3. 범용 레지스터(GPR, General Perpose Register)
- 다양하고 일반적인 상황에서 **범용적으로 자유롭게** 사용할 수 있는 레지스터
- 데이터, 명령어, 주소 모두 저장이 가능함
- CPU는 일반적으로 **여러 개의 범용 레지스터를** 가지고 있음
<br>

### 4. 플래그 레지스터(FR, Flag Register)
- **플래그(flag)** : 연산 결과나 CPU 상태에 대한 부가 정보로, 명령어 처리 과정에서 반드시 참조할 상태 정보를 의미하는 비트

<table width = 100%>
  <tr>
    <td><strong>종류</strong></td>
    <td><strong>설명</strong></td>
    <td><strong>사용 예시</strong></td>
  </tr>
  <tr>
    <td>부호 플래그</td>
    <td>연산 결과의 부호</td>
    <td>부호 플래그가 1일 경우 연산 결과는 음수, 0일 경우는 양수</td>
  </tr>
  <tr>
    <td>제로 플래그</td>
    <td>연산 결과가 0인지의 여부</td>
    <td>제로 플래그가 1일 경우 연산 결과는 0, 0일 경우 결과가 0이 아님</td>
  </tr>
  <tr>
    <td>캐리 플래그</td>
    <td>연산 결과에 올림수나 빌림수가 발생했는지의 여부</td>
    <td>캐리 플래그가 1일 경우에는 연산 결과에 올림수나 빌림수가 발생했고, 0일 경우 발생하지 않았음</td>
  </tr>
  <tr>
    <td>오버플로우 플래그</td>
    <td>오버플로우가 발생했는지의 여부</td>
    <td>오버플로우 플래그가 1일 경우에는 오버플로우가 발생했고, 0일 경우에는 발생하지 않았음</td>
  </tr>
  <tr>
    <td>인터럽트 플래그</td>
    <td>인터럽트가 가능한지의 여부</td>
    <td>인터럽트 플래그가 1일 경우에는 인터럽트가 가능함을 의미하고, 0일 경우에는 인터럽트가 불가능함을 의미</td>
  </tr>
  <tr>
    <td>슈퍼바이저 플래그</td>
    <td>커널 모드로 실행 중인지, 사용자 모드로 실행 중인지의 여부</td>
    <td>슈퍼바이저 플래그가 1일 경우에는 커널 모드로 실행 중임을 의미하고, 0일 경우에는 사용자 모드로 실행 중임을 의미</td>
  </tr>
</table>

**[예시]** CPU가 연산을 수행한 직후 다음과 같이 제로 플래그가 1이면 연산 결과는 0
<table>
  <tr>
    <td>부호 플래그</td>
    <td>제로 플래그</td>
    <td>캐리 플래그</td>
    <td>오버플로우 플래그</td>
    <td>인터럽트 플래그</td>
    <td>슈퍼바이저 플래그</td>
  </tr>
  <tr>
    <td>0</td>
    <td>1</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
    <td>0</td>
  </tr>
</table>

> 슈퍼바이저 플래그의 설명과 커널/사용자 모드의 내용은 3장 '운영체제'를 참고하자.
<br>

### 5. 스택 포인터(Stack Pointer)
- **스택 영역** : 실행 중인 프로그램이 메모리에 적재되어 각 프로그램들이 스택과 같은 형태로 사용 가능한 주소 공간
- **스택 포인터** : 메모리 내 스택 영역의 최상단 스택 데이터 위치를 가리키는 특별한 레지스터

스택의 **LIFO(Last In, First Out / 후입선출)** 구조에 따라서 데이터를 꺼내거나 추가해야 하면 최상단 스택 데이터 위치를 알고 있어야 데이터를 꺼내고 그 위에 새 스택 데이터를 가져올 수 있다. 결과적으로 마지막 스택 저장 데이터 위치를 가리키는 레지스터이자, **스택이 채워진 정도**&ZeroWidthSpace;를 나타내는 레지스터인 것이다.

---

## B. 인터럽트(Interrupt)
**인터럽트(Interrupt)**&ZeroWidthSpace;는 방해하다, 중단시키다라는 의미이다. CPU가 수행 중인 작업은 방해받아 중단될 수 있는데 **CPU의 작업을 방해하는 신호**&ZeroWidthSpace;를 인터럽트라고 한다.

- **동기 인터럽트(synchronous interrupts)** 
	CPU에 의해 발생하는 인터럽트로, 프로그래밍 오류 등의 **예외적 사항**&ZeroWidthSpace;을 마주치면 발생하는 인터럽트이기 때문에 **예외(exception)**&ZeroWidthSpace;라고도 부른다.

- **비동기/하드웨어 인터럽트(asynchronous/hardware interrupts)** 
	입출력 장치에 의해 발생하는 인터럽트로, 기계의 완료 알림처럼 **알림**&ZeroWidthSpace;의 역할을 한다.   
1) CPU가 프린터에게 출력을 부탁하고 작업을 끝낸 뒤 **완료 인터럽트**&ZeroWidthSpace;를 보냄
2) 키보드나 마우스가 입력을 받아들였을 때 이를 처리하기 위해 **입력 인터럽트**&ZeroWidthSpace;를 보냄
<br>

### 1. 하드웨어 인터럽트
CPU는 **효율적인 명령어 처리를 위해** 하드웨어 인터럽트를 활용한다.   
가령, 프린터에게 프린트를 요청했는데 입출력장치는 CPU보다 현저히 느리기 때문에 인터럽트가 없다면 **알림이 없이 완료 여부를 기다려야** 한다.

> 작업 완료 여부를 계속 확인하는 것은 인터럽트와 대비되는 **폴링(polling)** 이라는 기법으로 입출력장치의 상태가 어떤지, 처리 데이터가 있는지 **주기적으로 확인**&ZeroWidthSpace;하는 것이다.

하지만 하드웨어 인터럽트를 사용하면 작업 끝까지 기다릴 필요 없이 진행되는 동안 **온전히 다른 작업을 처리할 수 있다.** CPU 사이클 낭비를 최소화하고 다른 일을 수행할 시간을 벌어 효율적인 명령어 처리가 가능해진다. CPU는 일반적으로 하드웨어 인터럽트를 다음과 같은 순서대로 처리한다:

1. 입출력장치가 CPU에게 **인터럽트 요청 신호**를 보낸다.
2. CPU는 실행 사이클이 끝나고 명령어 인출 전에 인터럽트 여부를 항상 확인한다.
3. CPU는 인터럽트 요청을 확인하고, **인터럽트 플래그**를 통해 인터럽트를 받아들일 수 있는지 여부를 확인한다.
4. 인터럽트를 받아들일 수 있다면 CPU가 지금까지의 작업을 백업한다.
5. CPU는 **인터럽트 벡터**를 참조하여 **인터럽트 서비스 루틴**을 실행한다.
6. 인터럽트 서비스 루틴 실행이 종료되면 백업해둔 작업을 복구해 실행을 재개한다.
<br>

#### a. 인터럽트 요청 신호
인터럽트는 CPU의 작업을 고의적으로 끊는 것이기 때문에 인터럽트 전에 CPU에게 인터럽트 가능 여부를 확인해야 한다. 이런 신호를 **인터럽트 요청(IRQ, Interrupt ReQuest) 신호**&ZeroWidthSpace;라고 한다. 이때 인터럽트 요청을 수용하려면 플래그 레지스터의 인터럽트 플래그가 활성화되어 있어야 하고, 인터럽트 플래그가 받아들일지 무시할지를 결정한다. 불가능으로 설정되어 있다면 인터럽트 요청이 들어오더라도 이를 무시한다.   
다만, 모든 하드웨어 인터럽트를 인터럽트 플래그로 막을 수 있는 것은 아니다. **무시할 수 없는 인터럽트** 요청도 잇는데, 다시 말해 가장 먼저 처리해야 하는 우선순위가 높은 인터럽트인 것이다. 정전이나 하드웨어 고장으로 인한 인터럽트가 이에 속한다.

- 막을 수 **있는** 인터럽트 (Maskable Interrupt)
- 막을 수 **없는** 인터럽트 (NMI, Non-Maskable Interrupt) : 우선순위가 높아서 막을 수 없는 인터럽트. 정전 혹은 하드웨어 고장 등.
<br>

#### b. 인터럽트 서비스 루틴
**인터럽트 서비스 루틴(ISR, Interrupt Service Routine)**&ZeroWidthSpace;은 인터럽트를 처리하기 위한 프로그램으로, **인터럽트 핸들러(Interrupt Handler)**&ZeroWidthSpace;라고도 한다. 어떤 인터럽트의 발생 상황에서 해당 인터럽트를 **어떻게 처리하고 작동해야 할지에 대한 정보** 모음 프로그램이다. 즉, CPU는 **인터럽트 서비스 루틴을 실행하고, 본래 수행하던 작업으로 다시 되돌아오는 것**&ZeroWidthSpace;이다.

1. 정상적인 작업 실행
2. 인터럽트 발생 : 인터럽트 상황을 파악, 기존 작업 위치 및 작업을 백업
3. 인터럽트 서비스 루틴으로 점프 후 실행 : 처리 및 작동 정보 확인 후 실행
4. 기존 작업으로 리턴 후 작업 수행 재개

장치마다 인터럽트 처리 동작이 다르므로 인터럽트 서비스 루틴이 장치마다 다르다. 메모리에는 여러 개의 서비스 루틴이 저장되어 있고 하나하나가 **인터럽트가 발생하면 어떻게 해야 하는지를 알려주는 프로그램** 단위인 것이다. CPU는 그러면 이 루틴을 구분할 수 있어야 하기 때문에 여기서 **인터럽트 벡터(Interrupt Vector)**&ZeroWidthSpace;라는 서비스 루틴 식별을 위한 정보를 이용한다. CPU는 버스를 통해 하드웨어 인터럽트 요청을 보낸 대상으로부터 인터럽트 벡터를 받고, 동시에 **서비스 루틴의 시작 주소를 포함**&ZeroWidthSpace;하여 받기 때문에 처음부터 특정 인터럽트 서비스 루틴을 실행할 수 있다.

> 인터럽트를 처리한다는 것은 **서비스 루틴을 실행하고 본래 수행하던 작업으로 복귀**&ZeroWidthSpace;한다는 것이고, CPU가 루틴을 실행하려면 **인터럽트 서비스 루틴의 시작 주소**&ZeroWidthSpace;를 알아야 하며 이는 인터럽트 벡터를 통해 알 수 있다. 루틴 또한 프로그램 카운터 등 레지스터를 사용하며 실행한다. 이때 이전에 수행하던 일은 **백업**&ZeroWidthSpace;이 필요하기 때문에 **루틴 시작 전에 프로그램 재기를 위한 모든 내용**&ZeroWidthSpace;을 메모리 내 **스택**&ZeroWidthSpace;에 백업한다.

결국 인터럽트를 처리하는 인터럽트 사이클까지 포함한 명령어 사이클이 생성될 수 있다.
![](https://velog.velcdn.com/images/aoi-aoba/post/866e751b-7f22-4c21-8b35-28945376a3c6/image.png)


### 2. 예외(동기 인터럽트)
CPU는 예외가 발생하면 하던 일을 중단하고 예외를 처리한 뒤에 돌아와 본래 작업의 실행을 재개하는데, 이 과정에서 예외의 종류가 나누어진다.
<br>

#### a. 폴트(fault)
예외 처리 직후에 **예외가 발생한 명령어부터** 실행을 재개하는 예외의 종류
> CPU가 명령어 실행에 필요한 데이터가 메모리가 아닌 보조기억장치에 저장되어 있어서 폴트를 발생시켜 데이터를 가져온 뒤 **폴트가 발생한 명령어부터** 다시 실행
<br>

#### b. 트랩(trap)
예외 처리 직후에 **예외가 발생한 명령어의 다음 명령어부터** 실행을 재개하는 예외의 종류
- 디버깅의 브레이킹 포인트가 대표적 사례임
- 특정 코드 실행 순간에 프로그램을 멈추게 하고 중단시키고 트랩을 처리하면 발생 이후 명령어부터 실행하게 됨
<br>

#### c. 중단(abort)
CPU가 실행 중인 프로그램을 **강제로 중단**&ZeroWidthSpace;시킬 수밖에 없는 **심각한 오류가 발생**&ZeroWidthSpace;한 경우에 생기는 예외
<br>
<br>

#### d. 소프트웨어 인터럽트(software interrupt)
시스템 콜이 발생했을 때 발생하는 예외.
> 소프트웨어 인터럽트에 대해 자세한 것은 3장을 참고하자!
