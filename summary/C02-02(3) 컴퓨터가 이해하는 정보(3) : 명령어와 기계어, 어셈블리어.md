# C02-02(3) 컴퓨터가 이해하는 정보(3) : 명령어와 기계어, 어셈블리어

## #. 안내
> Computer Science(컴퓨터 과학) 관련 공부 후 직접 정리하는 정리본입니다.   
책을 기반으로 하고 있으나, 위키백과나 StackOverFlow 등의 사이트에서 추가로 더 알아보고 적는 내용들이 많이 있습니다.

---

## A. 명령어
명령어는 **수행할 동작** / **수행할 대상**&ZeroWidthSpace;으로 이루어져 있다. 수행할 대상은 동작에 사용될 **데이터 자체** 혹은 **저장된 위치**&ZeroWidthSpace;로 표현된다.

<table width = 100%>
  <tr>
    	<td><strong> 수행할 동작</strong></td>
    	<td colspan = "2"><strong> 수행할 대상 </strong></td>
  </tr>
  <tr>
            <td>plus</td>
            <td>integer 100</td>
            <td>and integer 200</td>
        </tr>
        <tr>
            <td>subtract</td>
            <td>value of address 32 in memory</td>
            <td>value of address 32 in memory</td>
        </tr>
        <tr>
            <td>save</td>
            <td>integer 10</td>
            <td>to address 128 in memory</td>
        </tr>
</table>

- **연산 코드(Operation Code)** : 명령어가 시작할 동작으로 연산자로도 부른다. CPU에 따라 종류가 다르고 종류가 매우 많다.
- **오퍼랜드(Operand)** : 피연산자로도 부르며, 동작에 사용될 데이터 혹은 데이터가 저장된 위치를 의미한다.

하나의 명령어는 연산 코드와 0개 이상의 오퍼랜드로 구성되며, 명령어에서 연산 코드가 담기는 영역은 **연산 코드 필드**, 오퍼랜드가 담기는 영역은 **오퍼랜드 필드**라 한다. 오퍼랜드 필드에서 그 값이 담기고 오퍼랜드의 갯수에 따라 0 - 주소 명령어, 1 - 주소 명령어, 2 - 주소 명령어, 3 - 주소 명령어 등이 있다.   

오퍼랜드 필드에는 연산 코드의 데이터가 직접 명시되기보다는 **저장된 위치(메모리 주소나 레지스터의 이름)**&ZeroWidthSpace;이 명시된다. 그래서 **주소 필드(address field)** 라는 이름으로 부르기도 한다. 명령어에 사용된 오퍼랜드에 메모리 주소가 명시되면 이 명령어를 실행하기 위한 메모리 접근도 필요해진다.
> 만약, CPU가 메모리에 접근해서 '100번지 값에 10을 더해라'라는 명령어를 인출했으면 오퍼랜드 필드에 명시된 메모리 주소를 통해 한 번 더 메모리에 접근해서 값을 인출해야 이 명령어가 실행될 수 있다.

연산 코드는 CPU에 따라 달라지지만 대부분의 CPU가 공통적으로 이해하는 연산 코드의 유형은 다음의 4가지이다:
- **데이터 전송** : MOVE(데이터를 옮겨라), STORE(메모리에 저장해라), LOAD/FETCH(메모리에서 데이터를 CPU로 가져와라), PUSH(데이터를 스택에 저장해라), POP(스택의 최상단 데이터를 가져와라)
- **산술/논리연산** : ADD/SUBTRACT/MULTIPLY/DIVIDE(해당 사칙연산을 수행해라), INCREMENT/DECREMENT(오퍼랜드에서 1을 더하거나 빼라), AND/OR/NOT(각 연산을 수행해라), COMPARE(두 숫자 혹은 TRUE/FALSE 값을 비교해라)
- **제어 흐름 변경** : JUMP(특정 주소로 실행 순서를 옮겨라), CONDITIONAL JUMP(조건에 부합하면 특정 주소로 실행 순서를 옮겨라), HALT(프로그램 실행을 멈춰라), CALL(되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라), RETURN(CALL 호출 시 저장한 주소로 돌아가라)
- **입출력 제어** : READ/INPUT(특정 입출력장치로부터 데이터를 읽어라), WRITE/OUTPUT(특정 입출력장치로 데이터를 써라), START IO(입출력장치를 시작해라), TEST IO(입출력장치의 현재 상태를 확인해라)

---
## B. 기계어(Machine Code)와 어셈블리어(Assembly Language)
- 기계어(Machine Code) : CPU가 이해할 수 있게 비트 단위(0과 1)로 표현된 정보를 있는 그대로 표현한 언어. 프로그램을 나타내는 **가장 낮은 단계의 개념(가장 낮은 수준의 인터페이스)**&ZeroWidthSpace;으로서 어셈블리어와 1:1로 쓰일 수 있다.
- 어셈블리어(Assembly Language) : 기계어를 읽기 편한 형태로 단순 번역한 언어. 숫자 기계 코드와 인간이 읽을 수 있는 버전 간의 **직접 매핑(direct mapping)**&ZeroWidthSpace;을 제공하여 인간이 읽을 수 있는 문자열로 대체한다.

어떤 프로그래밍 언어로 어떤 프로그램을 만들든, 컴퓨터 내부에서는 0과 1로 이루어진 **기계어**로 변환하여 프로그램을 실행하며 구체적 연산 코드 종류나 레지스터 이름, 명령어의 생김새는 CPU마다 다르다.

**1. 어떤 수를 반환하는 함수 (C언어 소스코드)**
```c
int square(int num) {
  return num * num;
}
```

**2. CISC 기반 CPU의 어셈블리어**
```assembly
push rbp
mov rbp, rsp
mov DWORD PTR [rbp-4], edi
mov eax, DWORD PTR [rbp-4]
imul eax, eax
pop rbp
ret
```

**3. RISC 기반 CPU의 어셈블리어**
```assembly
push {r7}
sub sp, sp, #12
add r7, sp, #0
str r0, [r7, #4]
ldr r3, [r7, #4]
mul r3, r3, r3
mov r0, r3
adds r7, r7, #12
mov sp, r7
ldr r7, [sp], #4
bx lr
```

명령어의 종류와 생김새는 CPU마다 다를 수 있기 때문에, 명령어가 다르면 기계어도 달라지고, 기계어를 그대로 번역한 어셈블리어 역시 달라질 수밖에 없다. 이런 어셈블리어는 문법을 익히는 것이 개발 직군에 따라 필요 여부는 달라지나 같은 프로그램일지라도 **CPU마다 이해하는 명령어가 다르면 실행이 불가할 수 있다** 라는 점은 기억해야 한다. 즉, 특정 CPU에 의존적인 코드로 만들지 않아야 한다.
> CISC와 RISC의 자세한 설명은 C02-03에서 다룬다.

---

## C. 명령어 사이클(Instruction Cycle)
메모리 안에 저장된 프로그램은 여러 명령어로 구성되어 있다. CPU는 이 메모리에서 명령어를 인출하고 실행하기를 반복하며 전체를 실행한다. 이 과정에서 CPU는 정형화된 흐름을 기반으로 하여 명령어를 처리하는데, 이때 명령어들이 **일정 주기를 반복**&ZeroWidthSpace;하며 실행된다. 이 주기를 **명령어 사이클**&ZeroWidthSpace;이라고 한다.

- **인출 사이클(fetch cycle)** : 명령어 사이클의 첫 번째 과정으로, 메모리에 있는 명령어를 CPU로 가져오는 단계이다.
- **실행 사이클(execution cycle)** : 명령어 사이클의 두 번째 과정으로, CPU로 가져온 명령어를 실행하는 단계이다.

CPU는 메모리 속 명령어를 가져와 실행하고, 가져와서 실행하는 것을 반복하며 실행하기 때문에 인출 사이클과 실행 사이클은 반복된다. 하지만 모든 명령어가 이렇게 단순히 실행되지는 않는다. 명령어를 인출해도 **곧바로 실행되지 않는 경우도** 있는데, A파트의 인용구 부분에서 적은 것처럼 오퍼랜드 필드에 메모리 주소가 명시된 경우가 대표적이다. CPU가 명령어를 인출했지만 메모리에 한 번 더 접근해야 하기 때문이다.

- **간접 사이클(indirect cycle)** : 명령어 사이클 내에서 명령어 실행을 위해 추가적인 메모리 접근이 필요하여 한 번 더 메모리에 접근하는 단계이다.

어떤 명령어는 인출과 실행 사이클만이 존재하고, 어떤 명령어는 인출과 실행, 간접 사이클까지 모두 거쳐 실행된다. 그리고 중요한 사이클이 하나 더 남아있다. 이 사이클은 **인터럽트 사이클**인데, 이해를 돕기 위해 CPU 레지스터에 대한 이해가 필요하므로 다음 절 C02-03에서 다루자.
