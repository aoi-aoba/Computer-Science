# C02-02(2) 컴퓨터가 이해하는 정보(2) : 문자의 인코딩과 디코딩

## #. 안내
> Computer Science(컴퓨터 과학) 관련 공부 후 직접 정리하는 정리본입니다.   
책을 기반으로 하고 있으나, 위키백과나 StackOverFlow 등의 사이트에서 추가로 더 알아보고 적는 내용들이 많이 있습니다.

---

## 문자의 인코딩(encoding)과 디코딩(decoding)

  - <strong> 문자 집합(Character set) </strong> : 컴퓨터가 이해할 수 있는 문자들의 집합
  - <strong> 문자 인코딩(Character Encoding) </strong> : 문자 집합에 속한 문자를 2진수로 이루어진 문자 코드로 변환하는 과정. 동일한 문자 집합이라도 다양한 문자 인코딩 방법이 있음
  - <strong> 문자 디코딩(Character Decoding) </strong> : 2진수로 이루어진 문자 코드를 사람이 이해하는 문자로 변환하는 과정 <br>

흔히 파일 혹은 글자가 깨졌다는 아래 현상은 특정  <strong> 인코딩 방법을 지원하지 않거나 </strong> 인코딩된 문자를  <strong> 디코딩하는 방법을 알지 못하는 경우</strong>에 흔히 발생한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/a36eb5fa-99ce-4a08-82bd-6603ae420265/image.png)

### 1. 아스키 코드 (ASCII, American Standard Code for Information Interchange)

초창기 컴퓨터에서 사용하던 문자 집합 중 하나이다.
 - 영어 알파벳, 아라비아 숫자 및 일부 특수문자를 포함한다.
 - 하나의 문자에 대해 8bit(1byte)를 사용한다.
 - <strong> 패리티 비트(parity bit) </strong> : 오류 검출을 위해 사용하는 비트로, 전체 중 1bit에 해당
 - 총 7비트를 사용하므로 $$2^7 = 128$$개 문자를 표현할 수 있음
 
![](https://velog.velcdn.com/images/aoi-aoba/post/a38144e1-21b1-403e-a739-4f3fa8a75636/image.png)

위의 아스키 코드표를 보면...
- 0에서 127의 숫자 중 하나에 대응되는 문자를 **아스키 문자**&ZeroWidthSpace;라고 한다.
- 아스키 문자 하나에 대응된 고유한 **아스키 코드**&ZeroWidthSpace;를 활용하여 2진수로 표현함으로써 아스키 문자를 대응시키는 인코딩 방식이다.

아스키 코드처럼 문자의 인코딩 과정에서 글자에 부여된 고유한 값을 **코드 포인트(Code point)**&ZeroWidthSpace;라고 부른다.
<br>
<br>

### 2. EUC-KR (한글 인코딩 방식)

아스키 코드가 한글을 표기할 수 없다는 단점이 있어 등장한 한글 인코딩 방식 중 하나이다.
- EUC-KR은 KS X 1001, KS X 1003이라는 문자 집합 기반의 인코딩 방식이다.
- 아스키 문자 표현은 **1byte**, 한글 글자 하나에는 **2byte** 크기를 부여한다.
- 2바이트 2진수는 4자리의 16진수로 표현이 가능하다.

![](https://velog.velcdn.com/images/aoi-aoba/post/d8a45502-ec85-4824-99c8-e096bfc4ede2/image.png)


위의 EUC-KR 관련 표를 보면...
- '가'라는 문자는 0xb0a0 행의 두 번째 열이므로 0xb0a1로 인코딩된다.
- '관'이라는 문자는 0xb0f0 행의 13번째 열이므로 0xb0fc로 인코딩된다.

EUC-KR 인코딩 방식을 사용하면 총 2,350개 정도의 한글 단어의 표현이 가능하다. 아스키 코드에 비해 표현할 수 있는 문자는 많아졌으나 **아직 모든 한글 조합의 표현이 가능할 정도로 많은 양은 아닌** 상태이다. 예를 들어 문자 집합에 정의되지 않은 '똠', '쀓' 등은 표현이 불가능하다.
<br>
<br>

### 3. 유니코드 (Unicode)

유니코드는 한글을 포함해 EUC-KR에 비해 더 많은 언어, 특수문자, 화살표, 이모티콘까지 코드로 표현이 가능한 **통일된 문자 집합**이다. 대부분의 언어를 지원하므로 국가별로 다른 문자 집합과 인코딩 방식이 필요 없어져 **현대 가장 많이 사용되는 문자 집합**&ZeroWidthSpace;이다.

![](https://velog.velcdn.com/images/aoi-aoba/post/f8af7466-be26-471e-9ab8-55d4659c8248/image.png)![](https://velog.velcdn.com/images/aoi-aoba/post/7e41a79e-ee31-462c-8816-5813f520e275/image.png)

유니코드 표를 참고해서 각각의 문자 아래 적힌 유니코드 코드 포인트를 활용한다. 가령,
- '결'은 ACB0이라고 적혀 있으므로 0xACB0(U+ACB0)이다.
- '흔'은 D754라고 적혀 있으므로 0xD754(U+D754)이다.


간혹 U+라는 문자열을 붙여서 나타내는 것은 **16진수의 유니코드** 표현을 의미하는 표기이다.   
유니코드는 아스키 코드나 EUC-KR이 글자에 부여된 값을 그대로 인코딩 값으로 삼는 것과 달리 이 값을 **다양한 방법으로 인코딩**&ZeroWidthSpace;한다. 가령 UTF-8, UTF-16, UTF-32 등이 그렇다. 이들은 **유니코드 문자에 부여된 값을 인코딩하는 방식** 이름인 것이다. **가변 길이 인코딩** 방식으로, 인코딩 결과의 길이가 일정치 않을 수 있다.

- **UTF-8**   
영어 및 ASCII 문자는 1바이트, 다른 문자는 2바이트 이상이며 한글은 3바이트로 표현한다. ASCII와의 호환성이 뛰어나고 저장공간을 효율적으로 사용한다. 일반적으로 리눅스 환경에서 사용된다.

- **UTF-16**   
2바이트 또는 4바이트로 문자를 표현한다. BMP(기본 다국어 평면)의 문자는 2바이트로, 이외의 문자는 4바이트로 표현한다. 주로 윈도우, 자바 환경에서 사용한다.

- **UTF-32**   
모든 문자를 고정된 4바이트로 표현하여 모든 문자 표현에 효율적이지만 저장공간과 전송 대역폭의 소모가 크다는 단점이 있다. 주로 임베디드 시스템과 몇가지 언어 라이브러리에서 사용된다.

<blockquote> <Strong> [ 추가로 알아두기 ] </Strong> <br>
  <Strong> 유니코드 평면 </Strong> : 유니코드 평면은 유니코드 전체를 논리적으로 나눈 구획에 해당한다. <br>
  - 0번부터 16번까지의 17개 평면이 있으며, 0번이 다국어 기본 평면이다. <br>
  - 아래 표는 유니코드 15.0기준 다국어 기본 평면 (총 164개 영역, 1칸당 256자)이다. <br>
  - U+0000부터 U+FFFF까지의 영역을 차지하여 거의 모든 근대 문자 및 특수 문자가 포함되어 있다. 한글과 한중일 통합 한자들이 대부분이다. <br>
  - 1번 평면은 다국어 보충 평면(Supplementary Multilingual Plane, SMP)이며, 옛 문자 및 음악이나 수학 기호 등에 사용한다. 유니코드 15.0 기준 151개 영역이 존재한다. (U+10000~U+1FBFF / 최대 U+1FFFF, 미사용 영역 포함) <br>
  - 2번 평면은 상형 문자 보충 평면(Supplementary Ideographic Plane, SIP)이며, 초기 유니코드에 포함되지 않은 한중일 통합 한자를 주로 담고 있다. (U+20000~U+2FA1F / 최대 U+2FFFF, 미사용 영역 포함) <br>
  - 3번 평면은 상형 문자 제3 평면(Tertiary Ideographic Plane, TIP)이며, 갑골 문자나 금문, 소전 따위의 문자나 추가 한중일 통합 한자 및 기타 옛 상형 문자 등을 위해 예약된 영역이다. (U+30000~U+323AF / 최대 U+3FFFF, 미사용 영역 포함) <br>
  - 4~13번 평면은 2015년 기준 아무 문자나 기호도 지정되지 않았다. <br>
  - 14번 평면은 특수 목적 보충 평면(Supplementary Special-purpose Plane, SSP)이며, 적은 수의 제어용 문자들이 들어 있다. <br>
  - 15번 평면과 16번 평면은 사용자 영역으로 특정 업체나 사용자 별로 할당해 쓸 수 있어서 소프트웨어간 및 글꼴간 호환성은 보장되지 않는다. </blockquote>

![](https://velog.velcdn.com/images/aoi-aoba/post/1b646453-8ba8-45a1-b091-a5b0044a3bef/image.png)

<br>
<br>

### 4. base64

base64는 문자 뿐만 아니라 **이진 데이터** 역시 변환할 수 있다. 문자보다는 이진 데이터의 인코딩에 많이 사용된다. 이미지 등 단순 문자 외 데이터까지 아스키 문자 형태로 표현이 가능하다. **사진 파일 등의 전송** 과정에서 이메일 원문을 확인하면 base64로 인코딩되는 것을 확인할 수 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/f4233ddd-7f92-47d7-a218-cf944f6f5fbb/image.png)

base64는 64진법을 의미한다. 그래서 인코딩 값의 표현에 **64개의 문자** 사용이 이루어진다. 64진수 하나는 $$2^6 = 64$$ 에서 지수인 6bit가 64진수 하나를 표현하는데 사용할 수 있다. 기본적으로 4개(24bit)씩 한 번에 변환된다.

![](https://velog.velcdn.com/images/aoi-aoba/post/598b3fd3-6851-421b-9818-da2013ea7c31/image.png)

1. **6비트씩 나누어지는 경우**   
예를 들어 문자열 abc가 있다면, 8비트 아스키 코드 97과 98, 99로 대응되므로   
01100001 / 01100010 / 01100011로 표현이 가능하다. 총 24비트이다.   
그러면 6비트씩 끊어서 반환하면   
011000 (Y) / 010110 (W) / 001001 (J) / 100011 (j) 가 된다.

2. **6비트씩 나누어지지 않는 경우**
예를 들어 문자열 ab가 있다면, 8비트 아스키 코드 2개 즉 16비트가 된다.   
그러면 4개의 6비트 코드를 만들기 위해 나누어 떨어지지 않는 자리를 0으로 채우는 **패딩(padding)** 과정을 거쳐 이 부분을 '='으로 인코딩한다.
즉, 011000 (Y) / 010110 (W) / 001000 (I) / 000000 (=) 가 된다.

3. **문자열 변환 예시**
문자열 'she runs'를 표현해보자. 아스키코드표를 참고하여 변환하면 16진수로   
53 68 65 20 72 75 6E 73   
다음과 같이 변환되는데, 이를 2진수로 변환하는 과정과 6비트로 나누는 과정을 모두 거치면 아래 표와 같다. 그 결과, U2hlIHJ1bnM= 으로 인코딩된다.

![](https://velog.velcdn.com/images/aoi-aoba/post/3c878c61-342c-43b4-94c3-51d2caab6eea/image.png)
